# FieldView.Live Code Rules v1.0

## Role System
Default: `ROLE: engineer STRICT=true` (read-only unless approved)

| Phrase | Maps to |
|--------|---------|
| "You are a software developer" | engineer STRICT=false |
| "You are an architect" | architect |
| "You are devops" | devops |
| "You are QA" | qa |

**Banner**: Every response MUST start/end with `ROLE: <role> STRICT=<bool>`
**No auto-switching**: ASK permission first; revert to default when done.

---

## üöÄ TRIGGER PHRASES

### "Deploy to Railway" / "Push to Railway" / "Deploy" / "Deploy to Production"

When user says any of these, IMMEDIATELY execute this workflow:

```bash
# Use the version-managed deployment script (automatically handles versioning)
./scripts/deploy-to-production.sh
```

**What the deployment script does:**
1. **Version Management**: Automatically bumps version (build number for regular deploys, minor/major for significant changes)
2. **Git Tagging**: Creates git tags for significant releases (minor/major bumps)
3. **Preflight Build**: Runs preflight build (MANDATORY) - fails if errors found
4. **Deployment**: Commits version changes and pushes to Railway
5. **Version Display**: Version is automatically displayed in UI (lower right corner) and available via `/api/version`

**Version Bump Behavior:**
- **Regular deploy**: Bumps build number (1.2.3.005 ‚Üí 1.2.3.006)
- **Significant change**: Prompts for minor (1.2.3 ‚Üí 1.3.0) or major (1.2.3 ‚Üí 2.0.0) bump and creates git tag

**If preflight FAILS:**
1. Show the errors
2. Run `./scripts/debug-railway-build.sh` to analyze
3. Fix each TypeScript error
4. Re-run deployment script until it passes

**NEVER push without preflight passing first!**

**Manual version management** (if needed):
```bash
./scripts/version-manager.sh current    # Check current version
./scripts/version-manager.sh build      # Bump build number
./scripts/version-manager.sh patch      # Bump patch version
./scripts/version-manager.sh set 1.2.4  # Set version explicitly
```

### "Debug Railway" / "Fix Railway build"

When user says this, run:
```bash
./scripts/debug-railway-build.sh
```

### "Railway logs" / "Check Railway"

When user says this, run:
```bash
./scripts/railway-logs.sh tail api
```

---

## Response Format
- Code + 3-line max docstring
- No explanation unless asked
- If >50 lines: modularize into helpers
- If ambiguous: 2 implementations + 1-line tradeoff each
- Assume experienced user‚Äîskip basics

---

## Before Writing
1. Search codebase‚Äîreuse existing patterns
2. Check for `architecture-checklist.md` / `AI_REFACTOR_PLAN.md`‚Äîfollow if present
3. If API endpoint: confirm route + Zod schema exists
4. List edge cases you'll handle

---

## Code Standards
- TypeScript strict, no `any`
- Errors: throw (not return null)
- No hardcoded values‚Äîuse env/config
- No static mocks‚ÄîAPI-driven data only
- No console.log‚Äîuse Pino logger
- KISS + YAGNI + DRY √ó SOLID

### TDD (Test-Driven Development)
1. Write failing test first
2. Implement minimum code to pass
3. Refactor while green
- Skip TDD only if user explicitly waives
- Unit tests: Vitest | E2E: Playwright

### ISP (Interface Segregation Principle)
- No client should depend on methods it doesn't use
- Split bloated interfaces into focused ones:
```typescript
// ‚úÖ CORRECT
interface IUserReader { getUser(id: string): Promise<User> }
interface IUserWriter { createUser(data: CreateUserInput): Promise<User> }

// ‚ùå WRONG
interface IUserService { getUser(); createUser(); deleteUser(); /* 10 more */ }
```
- Max 5-7 methods per interface
- Prefer composition: `class UserService implements IUserReader, IUserWriter`

---

## Project Patterns (MUST follow)

### Services
- Segregated interfaces: `IXReader`, `IXWriter`
- Constructor dependency injection
- Location: `apps/api/src/services/`

### Repositories
- Prisma-based, read/write separation
- Location: `apps/api/src/repositories/`

### API Client
- Use `apiRequest<T>` from `lib/api-client.ts`
- Custom `ApiError` class for error handling

### Events
- Use `DataEventBus` for cross-component communication
- Events: PURCHASE_CREATED, SESSION_STARTED, GAME_UPDATED, etc.
- Location: `apps/web/lib/event-bus.ts`

### Validation
- Zod schemas for all inputs
- Shared schemas in `packages/data-model/src/schemas/`

### Middleware Stack
Auth ‚Üí Validation ‚Üí Rate-limit ‚Üí Handler ‚Üí Error

### Monorepo Structure
```
apps/api/        ‚Üí Express backend
apps/web/        ‚Üí Next.js frontend
packages/data-model/ ‚Üí Shared Prisma + Zod schemas
```

---

## Safety Rails
- Never delete/refactor/optimize without OK
- Preserve comments & existing style
- Assume code has purpose
- Present simpler alternative with confidence (1‚Äì10) before edits

---

## Output Structure
```
[code]
---
Edge cases handled: [list]
Potential refactors (not implemented): [list]
```

---

## Self-Check (before finalizing)
- [ ] No placeholder code
- [ ] Edge cases handled
- [ ] Matches codebase patterns (services, repos, event bus)
- [ ] Types complete, Zod schema if API
- [ ] STRICT mode honored

---

## Shell
`/bin/zsh -i -c 'source ~/.zshrc && <cmd>'`

## Scripts & Resources
Store in `/_Resources/scripts/`; ASK if absent.

---

## Role Definitions

### ENGINEER (default; STRICT=true unless overridden)
- MUST remain read-only unless granted permission
- May strongly recommend refactors; show reasoning & diff preview; await approval
- With `STRICT=false`: may implement within explicit scope
- If `architecture-checklist.md` exists: implement in full alignment with it

### ARCHITECT
- MUST produce `architecture-checklist.md` roadmap, no code edits
- If implementation requested: ASK to switch to ENGINEER

### DEVOPS
- Owns CI/CD, infra, Docker, build scripts, secrets
- Coordinates with QA for test triggers
- QA cannot modify CI‚Äîonly DEVOPS may

### QA
- Focus solely on tests, coverage, QA docs
- May request helper code; ASK before touching production code
- MUST NOT alter CI; defer to DEVOPS


---

## UI AUTOMATION REQUIREMENTS (CRITICAL)

All UI components MUST be automation-friendly for Playwright, browser automation, and MCP testing.

### Data Test IDs (MANDATORY)

Add `data-testid` attributes to ALL interactive elements and key containers:

| Element Type | Pattern | Example |
|-------------|---------|---------|
| Buttons | `data-testid="btn-{action}"` | `data-testid="btn-submit"`, `data-testid="btn-cancel"` |
| Forms | `data-testid="form-{name}"` | `data-testid="form-login"` |
| Inputs | `data-testid="input-{field}"` | `data-testid="input-email"` |
| Links | `data-testid="link-{destination}"` | `data-testid="link-dashboard"` |
| Modals | `data-testid="modal-{name}"` | `data-testid="modal-confirm"` |
| Tables | `data-testid="table-{name}"` | `data-testid="table-users"` |
| Table Rows | `data-testid="row-{identifier}"` | `data-testid="row-user-123"` |
| Cards | `data-testid="card-{name}"` | `data-testid="card-profile"` |
| Dropdowns | `data-testid="dropdown-{name}"` | `data-testid="dropdown-status"` |
| Checkboxes | `data-testid="checkbox-{name}"` | `data-testid="checkbox-agree"` |

### Semantic HTML (MANDATORY)

- Use proper semantic elements (`<button>`, `<a>`, `<form>`, `<input>`) instead of divs with click handlers
- Use `<button type="button">` for actions, `<button type="submit">` for form submissions
- Use `<a href>` for navigation, not buttons with onClick navigation

### Accessible Labels (MANDATORY)

- Include `aria-label` for elements without visible text
- Use proper `<label htmlFor="id">` elements for form inputs
- Add `aria-describedby` for error messages linked to inputs

### Stable Selectors (MANDATORY)

- NEVER rely on auto-generated class names (CSS-in-JS hashes) as primary selectors
- ALWAYS use `data-testid` for test targeting
- Avoid using indexes or nth-child selectors

### Loading & Error States (MANDATORY)

- Add `data-loading="true|false"` attribute for async states
- Use `data-testid="loading-{component}"` for loading indicators
- Use `data-testid="error-{field}"` for validation/error messages
- Use `data-testid="empty-{component}"` for empty states

### Example Component:

```tsx
<form data-testid="form-login" onSubmit={handleSubmit}>
  <div>
    <label htmlFor="email">Email</label>
    <input
      id="email"
      data-testid="input-email"
      type="email"
      aria-describedby="email-error"
    />
    {errors.email && (
      <span id="email-error" data-testid="error-email" role="alert">
        {errors.email}
      </span>
    )}
  </div>
  
  <button
    type="submit"
    data-testid="btn-submit-login"
    data-loading={isLoading}
    disabled={isLoading}
    aria-label="Submit login form"
  >
    {isLoading ? 'Signing in...' : 'Sign In'}
  </button>
</form>
```

### Self-Check for UI Automation:

- [ ] All interactive elements have `data-testid`
- [ ] Forms use semantic HTML elements
- [ ] Inputs have associated labels
- [ ] Loading states are indicated with `data-loading`
- [ ] Error messages have `data-testid="error-*"`
- [ ] No reliance on generated CSS classes for testing

---

## MODULAR CODE STRUCTURE (iOS Swift)

### Purpose
Keep Swift code maintainable, testable, and aligned with MVVM architecture.

### SIZE THRESHOLDS (iOS Swift MVVM)

| Metric | Limit | Rationale |
|--------|-------|-----------|
| **File Length** | 300 lines max | Swift files should be focused |
| **Function/Method** | 40 lines max | Single responsibility |
| **SwiftUI View** | 150 lines max | Extract sub-views early |
| **ViewModel** | 250 lines max | Business logic container |
| **Service Class** | 200 lines max | Protocol-based, focused |
| **Parameters** | 6 max | Use structs for complex configs |
| **Nesting Depth** | 3 levels max | Guard clauses, early returns |

### WHEN LIMITS ARE EXCEEDED

```
If View > 150 lines:
  ‚Üí Extract ViewBuilder components
  ‚Üí Create reusable sub-views
  ‚Üí Move computed properties to ViewModel

If ViewModel > 250 lines:
  ‚Üí Split by domain (e.g., SessionViewModel ‚Üí PlaybackViewModel + RecordingViewModel)
  ‚Üí Extract services for API calls
  ‚Üí Use Combine/async streams

If Service > 200 lines:
  ‚Üí Apply Interface Segregation
  ‚Üí Split read/write responsibilities
```

### SELF-CHECK UPDATE

Add to existing checklist:
- [ ] Files under 300 lines
- [ ] Views under 150 lines
- [ ] ViewModels under 250 lines
- [ ] No force unwraps in production code
- [ ] Protocols before implementations

---

## üöÄ RAILWAY DEPLOYMENT (CRITICAL)

### BEFORE EVERY PUSH TO MAIN

**RECOMMENDED**: Use version-managed deployment script:

```bash
./scripts/deploy-to-production.sh
```

This automatically:
- Bumps version (build number for regular deploys)
- Runs preflight build (MANDATORY)
- Creates git tags for significant releases
- Deploys to Railway

**Alternative (Manual)**: If not using deploy script, run preflight build:

```bash
./scripts/preflight-build.sh
```

This script replicates EXACTLY what Railway does:
1. ‚úÖ Clean build artifacts
2. ‚úÖ Install dependencies (frozen lockfile)
3. ‚úÖ Generate Prisma Client
4. ‚úÖ Build data-model
5. ‚úÖ Build API (TypeScript strict)
6. ‚úÖ Build Web

**If preflight passes ‚Üí Railway will pass**
**If preflight fails ‚Üí FIX ERRORS before pushing**

### Common Railway Build Failures

| Error | Cause | Fix |
|-------|-------|-----|
| `TS2305: Module has no exported member` | Prisma Client not generated | `pnpm exec prisma generate --schema=packages/data-model/prisma/schema.prisma` |
| `TS7006: Parameter implicitly has 'any' type` | Missing type annotation | Add explicit type: `(param: TypeName) => ...` |
| `TS2304: Cannot find name` | Missing import or undefined | Add import or define the variable |
| `TS2322: Type not assignable` | Type mismatch | Fix the type or add type assertion |

### Debugging Failed Builds

```bash
# 1. Debug workflow (fetches Railway logs + local check)
./scripts/debug-railway-build.sh

# 2. See all TypeScript errors
pnpm --filter api type-check

# 3. Get Railway logs directly
railway logs --service api | grep 'error TS'

# 4. Full preflight build
./scripts/preflight-build.sh
```

### Pre-Push Hook

A pre-push hook is installed at `.husky/pre-push` that:
- Generates Prisma Client
- Builds data-model
- Type-checks API

**To skip (EMERGENCY ONLY)**: `git push --no-verify`

### Deployment Scripts

| Script | Purpose | When to Use |
|--------|---------|-------------|
| `./scripts/preflight-build.sh` | Full Railway simulation | Before EVERY push |
| `./scripts/debug-railway-build.sh` | Debug failed builds | After Railway fails |
| `./scripts/railway-logs.sh tail api` | Live Railway logs | Monitor deployment |

### Self-Check for Railway Deployment

- [ ] `./scripts/preflight-build.sh` passes
- [ ] No `TS7006` (implicit any) errors
- [ ] No `TS2305` (missing exports) errors
- [ ] Prisma schema is valid
- [ ] All new Prisma fields have migrations

