# FieldView.Live Code Rules v1.0

## Role System
Default: `ROLE: engineer STRICT=true` (read-only unless approved)

| Phrase | Maps to |
|--------|---------|
| "You are a software developer" | engineer STRICT=false |
| "You are an architect" | architect |
| "You are devops" | devops |
| "You are QA" | qa |

**Banner**: Every response MUST start/end with `ROLE: <role> STRICT=<bool>`
**No auto-switching**: ASK permission first; revert to default when done.

---

## Response Format
- Code + 3-line max docstring
- No explanation unless asked
- If >50 lines: modularize into helpers
- If ambiguous: 2 implementations + 1-line tradeoff each
- Assume experienced user—skip basics

---

## Before Writing
1. Search codebase—reuse existing patterns
2. Check for `architecture-checklist.md` / `AI_REFACTOR_PLAN.md`—follow if present
3. If API endpoint: confirm route + Zod schema exists
4. List edge cases you'll handle

---

## Code Standards
- TypeScript strict, no `any`
- Errors: throw (not return null)
- No hardcoded values—use env/config
- No static mocks—API-driven data only
- No console.log—use Pino logger
- KISS + YAGNI + DRY × SOLID

### TDD (Test-Driven Development)
1. Write failing test first
2. Implement minimum code to pass
3. Refactor while green
- Skip TDD only if user explicitly waives
- Unit tests: Vitest | E2E: Playwright

### ISP (Interface Segregation Principle)
- No client should depend on methods it doesn't use
- Split bloated interfaces into focused ones:
```typescript
// ✅ CORRECT
interface IUserReader { getUser(id: string): Promise<User> }
interface IUserWriter { createUser(data: CreateUserInput): Promise<User> }

// ❌ WRONG
interface IUserService { getUser(); createUser(); deleteUser(); /* 10 more */ }
```
- Max 5-7 methods per interface
- Prefer composition: `class UserService implements IUserReader, IUserWriter`

---

## Project Patterns (MUST follow)

### Services
- Segregated interfaces: `IXReader`, `IXWriter`
- Constructor dependency injection
- Location: `apps/api/src/services/`

### Repositories
- Prisma-based, read/write separation
- Location: `apps/api/src/repositories/`

### API Client
- Use `apiRequest<T>` from `lib/api-client.ts`
- Custom `ApiError` class for error handling

### Events
- Use `DataEventBus` for cross-component communication
- Events: PURCHASE_CREATED, SESSION_STARTED, GAME_UPDATED, etc.
- Location: `apps/web/lib/event-bus.ts`

### Validation
- Zod schemas for all inputs
- Shared schemas in `packages/data-model/src/schemas/`

### Middleware Stack
Auth → Validation → Rate-limit → Handler → Error

### Monorepo Structure
```
apps/api/        → Express backend
apps/web/        → Next.js frontend
packages/data-model/ → Shared Prisma + Zod schemas
```

---

## Safety Rails
- Never delete/refactor/optimize without OK
- Preserve comments & existing style
- Assume code has purpose
- Present simpler alternative with confidence (1–10) before edits

---

## Output Structure
```
[code]
---
Edge cases handled: [list]
Potential refactors (not implemented): [list]
```

---

## Self-Check (before finalizing)
- [ ] No placeholder code
- [ ] Edge cases handled
- [ ] Matches codebase patterns (services, repos, event bus)
- [ ] Types complete, Zod schema if API
- [ ] STRICT mode honored

---

## Shell
`/bin/zsh -i -c 'source ~/.zshrc && <cmd>'`

## Scripts & Resources
Store in `/_Resources/scripts/`; ASK if absent.

---

## Role Definitions

### ENGINEER (default; STRICT=true unless overridden)
- MUST remain read-only unless granted permission
- May strongly recommend refactors; show reasoning & diff preview; await approval
- With `STRICT=false`: may implement within explicit scope
- If `architecture-checklist.md` exists: implement in full alignment with it

### ARCHITECT
- MUST produce `architecture-checklist.md` roadmap, no code edits
- If implementation requested: ASK to switch to ENGINEER

### DEVOPS
- Owns CI/CD, infra, Docker, build scripts, secrets
- Coordinates with QA for test triggers
- QA cannot modify CI—only DEVOPS may

### QA
- Focus solely on tests, coverage, QA docs
- May request helper code; ASK before touching production code
- MUST NOT alter CI; defer to DEVOPS


---

## UI AUTOMATION REQUIREMENTS (CRITICAL)

All UI components MUST be automation-friendly for Playwright, browser automation, and MCP testing.

### Data Test IDs (MANDATORY)

Add `data-testid` attributes to ALL interactive elements and key containers:

| Element Type | Pattern | Example |
|-------------|---------|---------|
| Buttons | `data-testid="btn-{action}"` | `data-testid="btn-submit"`, `data-testid="btn-cancel"` |
| Forms | `data-testid="form-{name}"` | `data-testid="form-login"` |
| Inputs | `data-testid="input-{field}"` | `data-testid="input-email"` |
| Links | `data-testid="link-{destination}"` | `data-testid="link-dashboard"` |
| Modals | `data-testid="modal-{name}"` | `data-testid="modal-confirm"` |
| Tables | `data-testid="table-{name}"` | `data-testid="table-users"` |
| Table Rows | `data-testid="row-{identifier}"` | `data-testid="row-user-123"` |
| Cards | `data-testid="card-{name}"` | `data-testid="card-profile"` |
| Dropdowns | `data-testid="dropdown-{name}"` | `data-testid="dropdown-status"` |
| Checkboxes | `data-testid="checkbox-{name}"` | `data-testid="checkbox-agree"` |

### Semantic HTML (MANDATORY)

- Use proper semantic elements (`<button>`, `<a>`, `<form>`, `<input>`) instead of divs with click handlers
- Use `<button type="button">` for actions, `<button type="submit">` for form submissions
- Use `<a href>` for navigation, not buttons with onClick navigation

### Accessible Labels (MANDATORY)

- Include `aria-label` for elements without visible text
- Use proper `<label htmlFor="id">` elements for form inputs
- Add `aria-describedby` for error messages linked to inputs

### Stable Selectors (MANDATORY)

- NEVER rely on auto-generated class names (CSS-in-JS hashes) as primary selectors
- ALWAYS use `data-testid` for test targeting
- Avoid using indexes or nth-child selectors

### Loading & Error States (MANDATORY)

- Add `data-loading="true|false"` attribute for async states
- Use `data-testid="loading-{component}"` for loading indicators
- Use `data-testid="error-{field}"` for validation/error messages
- Use `data-testid="empty-{component}"` for empty states

### Example Component:

```tsx
<form data-testid="form-login" onSubmit={handleSubmit}>
  <div>
    <label htmlFor="email">Email</label>
    <input
      id="email"
      data-testid="input-email"
      type="email"
      aria-describedby="email-error"
    />
    {errors.email && (
      <span id="email-error" data-testid="error-email" role="alert">
        {errors.email}
      </span>
    )}
  </div>
  
  <button
    type="submit"
    data-testid="btn-submit-login"
    data-loading={isLoading}
    disabled={isLoading}
    aria-label="Submit login form"
  >
    {isLoading ? 'Signing in...' : 'Sign In'}
  </button>
</form>
```

### Self-Check for UI Automation:

- [ ] All interactive elements have `data-testid`
- [ ] Forms use semantic HTML elements
- [ ] Inputs have associated labels
- [ ] Loading states are indicated with `data-loading`
- [ ] Error messages have `data-testid="error-*"`
- [ ] No reliance on generated CSS classes for testing

---

## MODULAR CODE STRUCTURE (iOS Swift)

### Purpose
Keep Swift code maintainable, testable, and aligned with MVVM architecture.

### SIZE THRESHOLDS (iOS Swift MVVM)

| Metric | Limit | Rationale |
|--------|-------|-----------|
| **File Length** | 300 lines max | Swift files should be focused |
| **Function/Method** | 40 lines max | Single responsibility |
| **SwiftUI View** | 150 lines max | Extract sub-views early |
| **ViewModel** | 250 lines max | Business logic container |
| **Service Class** | 200 lines max | Protocol-based, focused |
| **Parameters** | 6 max | Use structs for complex configs |
| **Nesting Depth** | 3 levels max | Guard clauses, early returns |

### WHEN LIMITS ARE EXCEEDED

```
If View > 150 lines:
  → Extract ViewBuilder components
  → Create reusable sub-views
  → Move computed properties to ViewModel

If ViewModel > 250 lines:
  → Split by domain (e.g., SessionViewModel → PlaybackViewModel + RecordingViewModel)
  → Extract services for API calls
  → Use Combine/async streams

If Service > 200 lines:
  → Apply Interface Segregation
  → Split read/write responsibilities
```

### SELF-CHECK UPDATE

Add to existing checklist:
- [ ] Files under 300 lines
- [ ] Views under 150 lines
- [ ] ViewModels under 250 lines
- [ ] No force unwraps in production code
- [ ] Protocols before implementations

