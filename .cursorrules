# Auris Project - AI Assistant Rules

## üö® CRITICAL MANDATES - NEVER VIOLATE

These rules are **ABSOLUTE** and must be enforced in ALL code generation and suggestions.

---

## üö´ PRIMARY MANDATE: NO STATIC MOCKS

### FORBIDDEN - Never Create or Suggest

‚ùå **Static mock files** (e.g., `/src/mocks/users.json`)
‚ùå **Hardcoded mock data** in components
‚ùå **Mock directories** (`/mocks/`, `/mockData/`, `/__mocks__/`)
‚ùå **Inline mock arrays** or objects
‚ùå **Comment-based TODO mocks**

### Example of FORBIDDEN code:

```javascript
// ‚ùå FORBIDDEN - DO NOT GENERATE THIS
const mockUsers = [
  { id: 1, name: 'John Doe' },
  { id: 2, name: 'Jane Smith' }
];

// ‚ùå FORBIDDEN - DO NOT GENERATE THIS
import mockData from './mocks/data.json';

// ‚ùå FORBIDDEN - DO NOT GENERATE THIS
const [data, setData] = useState([{ id: 1, test: 'data' }]);
```

### REQUIRED Alternative

‚úÖ **ONLY use Swagger-driven mock API** (Prism)
‚úÖ **OR use local development API** with real database
‚úÖ **OR use feature-flagged development endpoints**

```javascript
// ‚úÖ CORRECT - GENERATE THIS INSTEAD
import { apiClient } from '@/api/apiClient';

const [data, setData] = useState([]);

useEffect(() => {
  apiClient.getData().then(setData); // Data from API (mock or real)
}, []);
```

---

## üìã SWAGGER-FIRST DEVELOPMENT

### Mandatory Workflow

Before implementing ANY API-related code:

1. **Check if Swagger spec exists** for the endpoint
2. **If not, tell the user to create Swagger spec first**
3. **Generate types from Swagger**
4. **Use generated types in implementation**

### Example Response Pattern

When user asks to implement an API endpoint:

```
‚ùå STOP: Before I implement this endpoint, we need to:

1. Define it in Swagger first (`swagger/api.yaml`)
2. Validate the Swagger spec
3. Generate TypeScript types
4. Start mock API server
5. Then implement frontend/backend

Would you like me to help create the Swagger definition first?
```

### In Code Generation

```typescript
// ‚úÖ ALWAYS use generated types from Swagger
import { User, ApiResponse } from '@/api/generated';

async function getUsers(): Promise<ApiResponse<User[]>> {
  return apiClient.get('/users');
}
```

---

## üèóÔ∏è ARCHITECTURE PRINCIPLES

### Event-Driven Architecture

‚úÖ **ALWAYS use DataEventBus** for inter-component communication
‚ùå **NEVER use direct function calls** across component boundaries

```javascript
// ‚úÖ CORRECT
import { dataEventBus, DataEvents } from '@/services/DataEventBus';

dataEventBus.emit(DataEvents.USER_CREATED, { userId });

// Subscribe elsewhere
dataEventBus.subscribe(DataEvents.USER_CREATED, (data) => {
  // Handle event
});

// ‚ùå WRONG - Don't do this across boundaries
userService.notifyUserCreated(userId);
```

### Interface Segregation Principle (ISP)

‚úÖ **Create focused, single-purpose interfaces**
‚ùå **Avoid bloated interfaces with many methods**

```typescript
// ‚úÖ CORRECT - Segregated interfaces
interface UserReader {
  getUser(id: string): Promise<User>;
  listUsers(params: ListParams): Promise<User[]>;
}

interface UserWriter {
  createUser(data: CreateUserData): Promise<User>;
  updateUser(id: string, data: UpdateUserData): Promise<User>;
}

// ‚ùå WRONG - Bloated interface
interface UserService {
  getUser(...): ...;
  listUsers(...): ...;
  createUser(...): ...;
  updateUser(...): ...;
  deleteUser(...): ...;
  // ... 20 more methods
}
```

### Test-Driven Development (TDD)

‚úÖ **Write tests BEFORE implementation** (unless user explicitly waives)
‚ùå **Don't implement without tests**

```javascript
// ‚úÖ CORRECT - Test first
describe('mergeUsers', () => {
  it('should merge users successfully', async () => {
    const result = await mergeUsers(source, target);
    expect(result.success).toBe(true);
  });
});

// Then implement
async function mergeUsers(source, target) {
  // Implementation
}
```

---

## üîê SECURITY AWARENESS

### Mock Mode Detection

When generating security-related code, ALWAYS support mock mode bypass:

```typescript
// ‚úÖ CORRECT - Mock-aware security
export async function requireAuth() {
  if (import.meta.env.VITE_API_MODE === 'mock') {
    // Mock mode: auto-authenticate
    return { user: { id: '1', role: 'admin' } };
  }
  
  // Real authentication
  const token = getAuthToken();
  return verifyToken(token);
}
```

### Never Hardcode Security Bypass

```typescript
// ‚ùå WRONG - Hardcoded bypass
if (true) { // TODO: remove in production
  return { authenticated: true };
}

// ‚úÖ CORRECT - Environment-based
if (import.meta.env.VITE_API_MODE === 'mock') {
  return { authenticated: true };
}
```

---

## üìù CODE GENERATION RULES

### When Asked to Create a Component

1. **Check if similar component exists** (search codebase first)
2. **Use existing patterns** from codebase
3. **Import from centralized locations** (@/api, @/services, @/utils)
4. **Use TypeScript** for type safety
5. **Follow Material-UI patterns** (if UI component)
6. **Add proper error handling**
7. **Include loading states**
8. **Use event bus** for communication

### When Asked to Create an API Endpoint

1. **STOP and ask about Swagger** first
2. **If Swagger exists**, use it to guide implementation
3. **If Swagger doesn't exist**, tell user to create it first
4. **Use Advanced Route Builder** pattern (existing in codebase)
5. **Add proper validation**
6. **Include error responses**
7. **Document with JSDoc**

### When Asked to Add a Feature

1. **Search codebase** for similar features
2. **Reuse existing utilities/services**
3. **Follow established patterns**
4. **Consider data layer first** (OData, services)
5. **Then build UI**
6. **Add tests**
7. **Update documentation**

---

## üö® ENFORCEMENT - Auto-Response Patterns

### If User Asks for Static Mocks

**Response:**
```
‚ùå I cannot create static mock files. This violates the project's architectural mandate.

Instead, I can help you with:
1. ‚úÖ Add this endpoint to Swagger specification
2. ‚úÖ Set up Prism mock API server
3. ‚úÖ Configure the frontend to use mock API
4. ‚úÖ Implement the real API endpoint

Which would you like to do?
```

### If User Asks to Skip Swagger

**Response:**
```
‚ùå I cannot implement API endpoints without Swagger specification. This is a mandatory requirement.

Let me help you create the Swagger spec first:
1. Define the endpoint in swagger/api.yaml
2. Validate the specification
3. Generate types
4. Then implement

Shall I create the Swagger definition?
```

### If User Asks for Non-Event-Driven Code

**Response:**
```
‚ö†Ô∏è  This approach doesn't follow the event-driven architecture mandate.

Instead of direct calls, I'll use the DataEventBus:
- Emit event: DataEvents.{EVENT_NAME}
- Subscribe where needed
- Loose coupling maintained

Proceeding with event-driven implementation...
```

---

## üìö REFERENCE DOCUMENTS

When explaining architectural decisions, reference:

- `ARCHITECTURAL_MANDATES.md` - Primary mandates
- `SWAGGER_AS_SOURCE_OF_TRUTH.md` - Swagger workflow
- `MOCK_API_SECURITY_MODES.md` - Security flexibility
- `DATABASE_PORTABILITY_STRATEGY.md` - Database abstraction
- `MOCK_API_MANDATE.md` - Developer guide

---

## üéØ CODE QUALITY STANDARDS

### Always Include

‚úÖ TypeScript types (prefer interfaces over types)
‚úÖ Error handling (try-catch, error boundaries)
‚úÖ Loading states (for async operations)
‚úÖ Proper imports (use @/ aliases)
‚úÖ JSDoc comments (for complex functions)
‚úÖ Event-driven communication (DataEventBus)
‚úÖ Validation (input validation, schema validation)

### Never Include

‚ùå Static mock data
‚ùå Hardcoded values (use config/env)
‚ùå Direct cross-component calls
‚ùå Bloated interfaces
‚ùå Magic numbers (use constants)
‚ùå console.log (use proper logging)
‚ùå Any/unknown types (use proper types)

---

## üîÑ WORKFLOW REMINDERS

### Before Writing Code

1. Search codebase for existing solutions
2. Check if Swagger spec exists (for API)
3. Review related components/services
4. Plan event-driven approach
5. Consider TDD

### While Writing Code

1. Use TypeScript strictly
2. Follow existing patterns
3. Use event bus for communication
4. Add proper error handling
5. Include loading states

### After Writing Code

1. Add tests
2. Check for linting errors
3. Verify no static mocks introduced
4. Ensure event-driven architecture
5. Update documentation if needed

---

## üí° HELPFUL PHRASES

When generating code, include comments like:

```javascript
// ‚úÖ Event-driven: Using DataEventBus per architectural mandate
dataEventBus.emit(DataEvents.USER_UPDATED, { userId });

// ‚úÖ Mock-aware: Supports mock mode for development
if (import.meta.env.VITE_API_MODE === 'mock') { ... }

// ‚úÖ Type-safe: Using Swagger-generated types
const users: User[] = await apiClient.getUsers();

// ‚úÖ ISP: Focused interface with single responsibility
interface UserReader { ... }
```

---

## üéì LEARNING FROM CODEBASE

### Existing Patterns to Follow

**DataEventBus usage:**
```javascript
// Already established in codebase
import { dataEventBus, DataEvents } from '../services/DataEventBus';
dataEventBus.emit(DataEvents.USER_CREATED, { userId });
```

**API Client usage:**
```javascript
// Already established in codebase
import { apiClient } from '../api/apiClient';
import { apiPath } from '../config/urls';
const response = await apiClient.get(apiPath('/users'));
```

**Advanced Route Builder:**
```javascript
// Already established in codebase
const { routeRegistry, createRoute } = require('./registry');
routeRegistry.register(createRoute(path, method, handler, options));
```

---

## ‚ö° QUICK REFERENCE CHECKLIST

Before submitting code:

- [ ] No static mocks
- [ ] Swagger exists (for API)
- [ ] Uses event bus (for communication)
- [ ] TypeScript types present
- [ ] Error handling included
- [ ] Loading states included
- [ ] Tests written (or TDD followed)
- [ ] Follows ISP
- [ ] No hardcoded values
- [ ] Proper imports (@/ aliases)

---

**Remember: These are MANDATES, not suggestions. Enforce them strictly!**
